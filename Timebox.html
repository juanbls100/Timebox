<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeboxing</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');

        :root {
            /* Fluorescent/Vibrant Palette with Blue/Grey/Black Base */
            --primary-color: #00BCD4; /* Cyan - vibrant primary */
            --primary-dark-color: #0097A7; /* Darker Cyan */
            --secondary-color: #FFEB3B; /* Yellow - strong accent */
            --background-color: rgba(44, 62, 80, 0.82); /* Dark Blue-Grey with more transparency */
            --surface-color: rgba(236, 240, 241, 0.7); /* Light Grey with more transparency */
            --text-color: #2c3e50; /* Dark text on light surfaces */
            --light-text-color: #7f8c8d; /* Medium grey text */
            --border-color: #bdc3c7; /* Light grey border */
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.2);

            /* Priority Colors (adjusted to new palette) */
            --priority-urgent: #E91E63; /* Pink/Red - vibrant */
            --priority-important: #FFC107; /* Amber - vibrant */
            --priority-normal: #4CAF50; /* Green - vibrant */
            /* Solid backgrounds for schedule items */
            --priority-urgent-bg: #F8BBD0; /* Light Pink */
            --priority-important-bg: #FFECB3; /* Light Amber */
            --priority-normal-bg: #C8E6C9; /* Light Green */

            --empty-slot-bg: #F5F5F5; /* Solid light grey for empty slots */
            --fixed-task-bg: #DCEDC8; /* Solid light green for fixed tasks */
            --fixed-task-border: #8BC34A; /* Medium green */
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background-image: url("https://media.licdn.com/dms/image/v2/C4E12AQFYW9IGgqpOZQ/article-cover_image-shrink_720_1280/article-cover_image-shrink_720_1280/0/1520114024769?e=2147483647&v=beta&t=gbEOHhSa6cEFWajJlQxO5KrUwMlum56hCZ9I-7oY2Fk");
            background-size: cover;
            background-attachment: fixed;
            background-position: center center;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background-color: var(--surface-color); /* More transparent */
            border-radius: 12px;
            box-shadow: 0 10px 30px var(--shadow-medium);
            width: 100%;
            max-width: 1200px;
            padding: 30px;
            box-sizing: border-box;
            margin-top: 50px;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 30px;
            font-weight: 700;
            font-size: 2.2em;
        }

        h2 {
            color: var(--primary-dark-color); /* Adjusted to new palette */
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.6em;
            text-align: center;
        }

        /* Navigation Menu */
        .main-nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            background-color: var(--primary-color);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-light);
            flex-wrap: wrap;
        }

        .main-nav button {
            background: none;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .main-nav button:hover {
            background-color: var(--primary-dark-color);
            transform: translateY(-1px);
        }

        .main-nav button.active {
            background-color: var(--primary-dark-color);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .input-section {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .input-section input[type="text"],
        .input-section select,
        .input-section input[type="date"],
        .input-section textarea { /* Added textarea */
            flex-grow: 1;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            color: var(--text-color);
            transition: border-color 0.3s ease;
            min-width: 150px;
            box-sizing: border-box; /* Prevent overflow */
        }

        .input-section input[type="date"] {
            flex-shrink: 0; /* Prevent shrinking */
            width: auto; /* Allow natural width */
            min-width: 120px; /* Ensure it's not too small */
        }

        .input-section select {
            flex-grow: 0;
            width: auto;
            min-width: 120px;
            cursor: pointer;
            background-color: var(--surface-color);
        }

        .input-section input[type="text"]:focus,
        .input-section select:focus,
        .input-section input[type="date"]:focus,
        .input-section textarea:focus { /* Added textarea */
            outline: none;
            border-color: var(--primary-color); /* Changed to primary color */
            box-shadow: 0 0 0 3px rgba(0, 188, 212, 0.2); /* Cyan shadow */
        }

        .input-section button {
            padding: 12px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .input-section button:hover {
            background-color: var(--primary-dark-color);
            transform: translateY(-2px);
        }

        /* Statistics Section */
        .statistics-section {
            background-color: var(--surface-color); /* More transparent */
            border-radius: 12px;
            box-shadow: 0 2px 10px var(--shadow-light);
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }

        .stats-summary p {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .stats-summary span {
            font-weight: 700;
            color: var(--primary-dark-color); /* Adjusted to new palette */
        }

        .app-page {
            display: none; /* Hidden by default */
        }

        .app-page.active {
            display: block; /* Shown when active */
        }

        /* Capture Page Specific Layout */
        #capture-page .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        #capture-page .unassigned-tasks-section,
        #capture-page .daily-reminders-section,
        #capture-page .daily-schedule-section {
            flex: 1 1 300px;
            background-color: var(--surface-color); /* More transparent */
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px var(--shadow-light);
            box-sizing: border-box;
        }
        #capture-page .daily-schedule-section {
            flex: 2 1 400px;
        }


        .daily-reminders-section .input-section {
            margin-bottom: 20px; /* Smaller margin for reminder input */
        }
        .daily-reminders-section .input-section input[type="text"] {
            min-width: 100px; /* Allow smaller input for reminders */
        }

        .task-list {
            list-style: none;
            padding: 0;
        }

        .task-item { /* For unassigned tasks and reminders */
            display: flex;
            align-items: center;
            background-color: var(--surface-color); /* More transparent */
            border: 1px solid var(--border-color);
            border-left: 5px solid var(--border-color); /* Border for priority */
            border-radius: 8px;
            margin-bottom: 12px;
            padding: 15px 20px;
            box-shadow: 0 2px 10px var(--shadow-light);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.3s ease, background-color 0.3s ease;
        }

        .task-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 15px var(--shadow-medium);
        }

        /* Fixed task specific style */
        .task-item.is-fixed {
            background-color: var(--fixed-task-bg);
            border-left-color: var(--fixed-task-border);
        }

        /* Priority Styles */
        .task-item.priority-Urgent, .schedule-task-item.priority-Urgent {
            border-left-color: var(--priority-urgent);
            background-color: var(--priority-urgent-bg);
        }
        .task-item.priority-Important, .schedule-task-item.priority-Important {
            border-left-color: var(--priority-important);
            background-color: var(--priority-important-bg);
        }
        .task-item.priority-Normal, .schedule-task-item.priority-Normal {
            border-left-color: var(--priority-normal);
            background-color: var(--priority-normal-bg);
        }

        .task-item.completed {
            background-color: #E8F5E9; /* A very light green for completed, solid */
            opacity: 0.8;
            border-left-color: #a5d6a7; /* Softer color for completed */
        }

        .task-item.completed .task-text {
            text-decoration: line-through;
            color: var(--light-text-color);
        }

        .task-checkbox {
            margin-right: 15px;
            min-width: 20px;
            min-height: 20px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .task-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .task-text {
            font-size: 1.1em;
            color: var(--text-color);
            word-break: break-word;
            margin-bottom: 5px;
        }

        .task-priority-display {
            font-size: 0.85em;
            color: var(--text-color); /* Changed to text-color for better contrast on solid background */
            text-transform: uppercase;
            font-weight: 500;
        }
        .task-responsible-display { /* New style for responsible person */
            font-size: 0.8em;
            color: var(--text-color); /* Changed to text-color for better contrast */
            font-style: italic;
            margin-top: 2px;
        }

        .task-actions {
            display: flex;
            gap: 8px;
            margin-left: 20px;
        }

        .task-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            color: var(--light-text-color);
            transition: color 0.3s ease;
            padding: 5px;
        }

        .task-actions button:hover {
            color: var(--secondary-color);
        }

        .task-actions button.delete-btn:hover {
            color: #e53935;
        }
        .task-actions button.assign-btn {
            background-color: var(--secondary-color); /* Fluorescent yellow */
            color: var(--text-color); /* Dark text on yellow */
            padding: 8px 12px;
            font-size: 0.9em;
            border-radius: 6px;
        }
        .task-actions button.assign-btn:hover {
            background-color: #FBC02D; /* Darker yellow */
            color: var(--text-color);
        }


        .empty-state {
            text-align: center;
            color: var(--light-text-color);
            font-size: 1.1em;
            margin-top: 20px;
            padding: 20px;
            border: 1px dashed var(--border-color);
            border-radius: 8px;
        }

        /* Schedule Grid Styles */
        .schedule-grid {
            display: grid;
            grid-template-columns: 80px 1fr; /* Column for time, column for activity */
            grid-auto-rows: minmax(25px, auto); /* Each 15-min slot is 25px min height */
            gap: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .time-label-cell { /* Cell in the first column for the time label */
            grid-column: 1;
            border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            box-sizing: border-box;
            display: flex;
            align-items: flex-start; /* Align text to the top of the slot */
            padding-top: 10px;
            font-size: 0.9em;
            color: var(--text-color);
            line-height: 1;
            background-color: var(--surface-color); /* More transparent */
        }

        .time-label-cell.hourly-label { /* Specific styles for hourly labels */
            background-color: #E0E0E0; /* Solid light grey */
            font-weight: 500;
            justify-content: center;
        }

        .schedule-cell { /* Empty cell in the schedule */
            grid-column: 2;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--empty-slot-bg); /* Solid light grey */
            box-sizing: border-box;
        }

        /* Remove bottom border from the last row */
        .schedule-grid > *:nth-last-child(2),
        .schedule-grid > *:last-child {
            border-bottom: none;
        }

        .schedule-task-item { /* The actual task displayed in the schedule */
            grid-column: 2;
            width: calc(100% - 2px);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 5px 10px;
            box-sizing: border-box;
            border-radius: 8px;
            box-shadow: 0 2px 5px var(--shadow-light);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            position: relative;
            z-index: 1;
            margin: 1px;
            border: 1px solid var(--border-color);
            border-left: 5px solid; /* Priority border */
        }

        .schedule-task-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px var(--shadow-medium);
        }

        .schedule-task-item.completed {
            opacity: 0.8;
            text-decoration: line-through;
            color: var(--light-text-color);
            border-left-color: #a5d6a7;
        }
        .schedule-task-item.completed .task-text {
             text-decoration: line-through;
             color: var(--light-text-color);
        }
        .schedule-task-item.completed .task-priority-display {
             color: var(--light-text-color);
        }

        /* Fixed task style in schedule */
        .schedule-task-item.is-fixed {
            background-color: var(--fixed-task-bg); /* Solid light green */
            border-left-color: var(--fixed-task-border);
        }


        .schedule-task-item .task-text {
            font-size: 1em;
            margin-bottom: 2px;
            word-break: break-word;
        }
        .schedule-task-item .task-priority-display {
            font-size: 0.75em;
            color: var(--text-color); /* Changed to text-color for better contrast */
            text-transform: uppercase;
            font-weight: 500;
        }
        .schedule-task-item .task-score { /* New style for score display */
            font-size: 0.75em;
            color: var(--secondary-color); /* Fluorescent yellow */
            font-weight: 700;
            position: absolute;
            bottom: 5px;
            left: 5px;
            /* Removed background and padding */
            z-index: 2;
        }
        /* Checkbox and actions positioning within schedule-task-item */
        .schedule-task-item .task-checkbox {
            position: absolute;
            top: 5px;
            right: 5px;
            margin-right: 0;
            z-index: 2;
        }
        .schedule-task-item .task-actions {
            position: absolute;
            bottom: 5px;
            right: 5px;
            margin-left: 0;
            background-color: rgba(255, 255, 255, 0.0); /* Made transparent */
            border-radius: 5px;
            padding: 2px;
            display: flex;
            gap: 2px;
            z-index: 2;
        }
        .schedule-task-item .task-actions button {
            font-size: 1em;
            padding: 3px;
            color: var(--light-text-color);
        }
        .schedule-task-item .task-content {
            padding-right: 40px; /* Make space for checkbox */
            padding-bottom: 25px; /* Make space for action buttons */
        }


        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--surface-color); /* More transparent */
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px var(--shadow-medium);
            width: 90%;
            max-width: 400px;
            max-height: 90vh; /* Set max height to 90% of viewport height */
            overflow-y: auto; /* Add scroll if content exceeds max-height */
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .modal-content.large { /* For AI analysis modal */
            max-width: 600px;
            text-align: left;
        }


        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h3 {
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.4em;
        }

        .modal-content p {
            color: var(--light-text-color);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .modal-content label {
            text-align: left;
            font-size: 0.9em;
            color: var(--light-text-color);
            margin-bottom: 5px;
            display: block;
        }

        .modal-content input[type="text"],
        .modal-content select,
        .modal-content textarea { /* Added textarea */
            width: calc(100% - 24px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            box-sizing: border-box; /* Prevent overflow */
        }
        .modal-content textarea {
            min-height: 80px;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            /* Ensure buttons are at the bottom and visible */
            flex-shrink: 0; /* Prevent buttons from shrinking */
            padding-top: 10px; /* Add some padding above buttons */
            background-color: var(--surface-color); /* Match modal background for seamless look */
            border-top: 1px solid var(--border-color); /* Optional: a subtle separator */
            position: sticky; /* Stick to the bottom of the scrollable area */
            bottom: 0;
            z-index: 1001; /* Ensure buttons are above scrollable content */
        }

        .modal-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .modal-buttons button.confirm-btn {
            background-color: var(--primary-color);
            color: white;
        }

        .modal-buttons button.confirm-btn:hover {
            background-color: var(--primary-dark-color);
            transform: translateY(-1px);
        }

        .modal-buttons button.cancel-btn {
            background-color: #e0e0e0;
            color: var(--text-color);
        }

        .modal-buttons button.cancel-btn:hover {
            background-color: #bdbdbd;
            transform: translateY(-1px);
        }

        /* Responsive adjustments */
        @media (max-width: 992px) {
            .main-nav {
                gap: 10px;
                padding: 10px;
            }
            .main-nav button {
                padding: 8px 15px;
                font-size: 1em;
            }
            .main-content {
                flex-direction: column;
            }
            .unassigned-tasks-section,
            .daily-reminders-section,
            .daily-schedule-section {
                min-width: unset;
                width: 100%;
            }
            .container {
                padding: 20px;
                margin-top: 20px;
            }
            .input-section {
                flex-direction: column;
                align-items: stretch;
            }
            .input-section button,
            .input-section select,
            .input-section input[type="date"],
            .input-section textarea { /* Added textarea */
                width: 100%;
            }
            .task-item {
                flex-direction: column;
                align-items: flex-start;
                padding: 15px;
            }
            .task-checkbox {
                margin-bottom: 10px;
                margin-right: 0;
            }
            .task-content {
                width: 100%;
                margin-bottom: 10px;
            }
            .task-actions {
                margin-left: 0;
                width: 100%;
                justify-content: flex-end;
            }
            .schedule-grid {
                grid-template-columns: 60px 1fr;
            }
            .time-label-cell {
                padding: 8px 10px;
                font-size: 0.8em;
            }
            .schedule-task-item {
                padding: 5px;
            }
            .schedule-task-item .task-text {
                font-size: 0.9em;
            }
            .schedule-task-item .task-priority-display {
                font-size: 0.7em;
            }
            /* Adjust positioning for schedule items on mobile */
            .schedule-task-item .task-checkbox {
                top: 5px;
                right: 5px;
            }
            .schedule-task-item .task-actions {
                bottom: 5px;
                right: 5px;
            }
            .schedule-task-item .task-content {
                padding-right: 40px;
                padding-bottom: 25px;
            }
            .schedule-task-item .task-score {
                bottom: 5px;
                left: 5px;
            }
        }

        @media (max-width: 480px) {
            .modal-content {
                padding: 20px;
            }
            .modal-buttons {
                flex-direction: column;
                gap: 10px;
            }
            .modal-buttons button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Timeboxing</h1>

        <nav class="main-nav">
            <button data-page="capture-page" class="active">Capture</button>
            <button data-page="fixed-activities-page">Fixed Activities</button>
            <button data-page="statistics-page">Statistics</button>
            <button data-page="dashboard-page">Dashboard</button>
        </nav>

        <!-- Capture Page -->
        <div id="capture-page" class="app-page active">
            <div class="input-section">
                <input type="date" id="captureDate" aria-label="Select Date">
                <input type="text" id="taskInput" placeholder="Add new activity..." aria-label="Add new activity">
                <!-- Priority select removed from here -->
                <button id="addTaskBtn">Add Activity</button>
            </div>

            <div class="main-content">
                <div class="unassigned-tasks-section">
                    <h2>Unassigned Tasks</h2>
                    <ul class="task-list" id="unassignedTaskList">
                        <!-- Unassigned tasks will be added here -->
                    </ul>
                    <div class="empty-state" id="emptyUnassignedState">
                        No unassigned tasks.
                    </div>
                </div>

                <!-- Daily Reminders Section -->
                <div class="daily-reminders-section">
                    <h2>Daily Reminders</h2>
                    <div class="input-section reminder-input">
                        <input type="text" id="reminderInput" placeholder="Add reminder..." aria-label="Add new reminder">
                        <button id="addReminderBtn">Add</button>
                    </div>
                    <ul class="task-list" id="reminderList">
                        <!-- Reminders will go here -->
                    </ul>
                    <div class="empty-state" id="emptyReminderState">
                        No reminders.
                    </div>
                </div>

                <div class="daily-schedule-section">
                    <h2>My Daily Schedule</h2>
                    <div class="schedule-grid" id="scheduleGrid">
                        <!-- Time slots and assigned tasks will be added here -->
                    </div>
                    <div class="empty-state" id="emptyScheduleState" style="display: none;">
                        Your schedule is empty. Assign some tasks!
                    </div>
                </div>
            </div>
        </div>

        <!-- Fixed Activities Page -->
        <div id="fixed-activities-page" class="app-page">
            <h2>Fixed Activities</h2>
            <div class="input-section">
                <input type="text" id="fixedTaskInput" placeholder="Add fixed activity..." aria-label="Add fixed activity">
                <!-- Removed fixedPrioritySelect, fixedDurationSelect, fixedTimeSlotSelect from here -->
                <button id="addFixedTaskBtn">Add Fixed</button>
            </div>
            <ul class="task-list" id="fixedTaskList"></ul>
            <div class="empty-state" id="emptyFixedState">No fixed activities.</div>
        </div>

        <!-- Statistics Page -->
        <div id="statistics-page" class="app-page">
            <div class="statistics-section">
                <h2>Statistics</h2>
                <div class="input-section" style="justify-content: center;">
                    <input type="date" id="statsDate" aria-label="Select Statistics Date">
                </div>
                <div class="stats-summary">
                    <p>Goal Score: <span id="goalScore">0</span></p>
                    <p>Completed Tasks: <span id="completedTasksCount">0</span></p>
                    <p>Total Score for the Day: <span id="totalScore">0</span></p>
                    <p>Completion Percentage: <span id="completionPercentage">0%</span></p>
                </div>
                <div class="input-section" style="flex-direction: column; align-items: stretch;">
                    <label for="observationsTextarea" style="text-align: left; margin-bottom: 5px;">Observations:</label>
                    <textarea id="observationsTextarea" placeholder="Write your observations for the day..."></textarea>
                    <button id="saveObservationsBtn" style="margin-top: 10px;">Save Observations</button>
                </div>
                <div class="empty-state" id="emptyStatsState">Complete tasks to see your statistics.</div>
            </div>
        </div>

        <!-- Dashboard Page -->
        <div id="dashboard-page" class="app-page">
            <h2>Dashboard</h2>
            <p>Here you'll see a summary of your daily progress.</p>
            <div style="width: 100%; max-width: 800px; margin: 20px auto; background-color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                <canvas id="scoreChart"></canvas>
            </div>
            <div class="empty-state" id="emptyDashboardState" style="display: none;">
                No data available to display in the dashboard. Complete some tasks!
            </div>
        </div>
    </div>

    <!-- Custom Modal HTML -->
    <div class="modal-overlay" id="customModal">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <input type="text" id="modalInput" style="display: none;">
            <label for="modalPrioritySelect" id="modalPriorityLabel" style="display: none;">Priority:</label>
            <select id="modalPrioritySelect" style="display: none;" aria-label="Activity priority">
                <option value="Normal">Normal</option>
                <option value="Important">Important</option>
                <option value="Urgent">Urgent</option>
            </select>
            <label for="modalTimeSlotSelect" id="modalTimeSlotLabel" style="display: none;">Assign to time slot:</label>
            <select id="modalTimeSlotSelect" style="display: none;" aria-label="Activity time slot">
                <!-- Options will be dynamically populated -->
            </select>
            <label for="modalDurationSelect" id="modalDurationLabel" style="display: none;">Duration:</label>
            <select id="modalDurationSelect" style="display: none;" aria-label="Activity duration">
                <!-- Options will be dynamically populated -->
            </select>
            <label for="modalResponsibleInput" id="modalResponsibleLabel" style="display: none;">Responsible:</label>
            <input type="text" id="modalResponsibleInput" style="display: none;" placeholder="Responsible person (optional)">

            <div class="modal-buttons">
                <button class="confirm-btn" id="modalConfirmBtn">OK</button>
                <button class="cancel-btn" id="modalCancelBtn" style="display: none;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Main App Elements
            const navButtons = document.querySelectorAll('.main-nav button');
            const appPages = document.querySelectorAll('.app-page');

            // Capture Page Elements
            const captureDateInput = document.getElementById('captureDate');
            const taskInput = document.getElementById('taskInput');
            const addTaskBtn = document.getElementById('addTaskBtn');
            const unassignedTaskList = document.getElementById('unassignedTaskList');
            const emptyUnassignedState = document.getElementById('emptyUnassignedState');
            const scheduleGrid = document.getElementById('scheduleGrid');
            const emptyScheduleState = document.getElementById('emptyScheduleState');

            const reminderInput = document.getElementById('reminderInput');
            const addReminderBtn = document.getElementById('addReminderBtn');
            const reminderList = document.getElementById('reminderList');
            const emptyReminderState = document.getElementById('emptyReminderState');

            // Fixed Activities Page Elements
            const fixedTaskInput = document.getElementById('fixedTaskInput');
            // Removed fixedPrioritySelect, fixedDurationSelect, fixedTimeSlotSelect from here
            const addFixedTaskBtn = document.getElementById('addFixedTaskBtn');
            const fixedTaskList = document.getElementById('fixedTaskList');
            const emptyFixedState = document.getElementById('emptyFixedState');

            // Statistics Page Elements
            const statsDateInput = document.getElementById('statsDate');
            const goalScoreSpan = document.getElementById('goalScore');
            const completedTasksCountSpan = document.getElementById('completedTasksCount');
            const totalScoreSpan = document.getElementById('totalScore');
            const completionPercentageSpan = document.getElementById('completionPercentage');
            const observationsTextarea = document.getElementById('observationsTextarea');
            const saveObservationsBtn = document.getElementById('saveObservationsBtn');
            const emptyStatsState = document.getElementById('emptyStatsState');

            // Dashboard Page Elements
            const dashboardCanvas = document.getElementById('scoreChart');
            const emptyDashboardState = document.getElementById('emptyDashboardState');
            let scoreChartInstance = null; // To hold the Chart.js instance

            // Modal elements
            const customModal = document.getElementById('customModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalInput = document.getElementById('modalInput');
            const modalPrioritySelect = document.getElementById('modalPrioritySelect');
            const modalPriorityLabel = document.getElementById('modalPriorityLabel');
            const modalTimeSlotSelect = document.getElementById('modalTimeSlotSelect');
            const modalTimeSlotLabel = document.getElementById('modalTimeSlotLabel');
            const modalDurationSelect = document.getElementById('modalDurationSelect');
            const modalDurationLabel = document.getElementById('modalDurationLabel');
            const modalResponsibleInput = document.getElementById('modalResponsibleInput');
            const modalResponsibleLabel = document.getElementById('modalResponsibleLabel');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');

            // Data storage
            let timeboxData = JSON.parse(localStorage.getItem('timebox_data')) || {
                tasksByDate: {},
                remindersByDate: {},
                fixedActivities: [], // Each fixed activity will now have a `completedDates` array
                dailyScores: {},
                dailyObservations: {}
            };

            let currentDate = new Date(); // Date for Capture/Dashboard
            let statsDate = new Date(); // Date for Statistics page

            // Helper function to generate unique IDs
            const generateUniqueId = () => '_' + Math.random().toString(36).substr(2, 9);

            // Helper function to format date to YYYY-MM-DD
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            // Helper function to convert time string "HH:MM" to total minutes from midnight
            const timeToMinutes = (timeString) => {
                if (!timeString) return null;
                const [hours, minutes] = timeString.split(':').map(Number);
                return hours * 60 + minutes;
            };

            // Helper function to convert total minutes from midnight to time string "HH:MM"
            const minutesToTime = (totalMinutes) => {
                if (totalMinutes === null) return null;
                const hours = String(Math.floor(totalMinutes / 60)).padStart(2, '0');
                const minutes = String(totalMinutes % 60).padStart(2, '0');
                return `${hours}:${minutes}`;
            };

            // Options for the duration dropdown (extended to 4 hours)
            const durationOptions = [
                { value: 15, text: '15 min' },
                { value: 30, text: '30 min' },
                { value: 60, text: '1 hr' },
                { value: 90, text: '1.5 hrs' },
                { value: 120, text: '2 hrs' },
                { value: 150, text: '2.5 hrs' },
                { value: 180, text: '3 hrs' },
                { value: 240, text: '4 hrs' }
            ];

            // Fibonacci sequence for scoring: 1, 2, 3, 5, 8, 13
            const fib = [0, 1, 2, 3, 5, 8, 13];
            const priorityScores = {
                'Normal': fib[1],     // 1
                'Important': fib[2], // 2
                'Urgent': fib[3]     // 3
            };
            const durationScores = {
                15: fib[1],   // 1
                30: fib[2],   // 2
                60: fib[3],   // 3
                90: fib[4],   // 5
                120: fib[5],  // 8
                150: fib[6],  // 13
                180: fib[6],  // 13 (capped at fib[6] as per user request)
                240: fib[6]   // 13 (capped at fib[6] as per user request)
            };

            // Helper function to show custom modal
            const showModal = (title, message, isPrompt = false, defaultValue = '', isConfirm = false, currentPriority = 'Normal', currentAssignedSlot = null, currentDuration = 30, isReminderAssignment = false, isLarge = false, itemIdBeingEdited = null, currentResponsible = '') => {
                return new Promise((resolve) => {
                    modalTitle.textContent = title;
                    modalMessage.textContent = message;

                    modalInput.style.display = isPrompt ? 'block' : 'none';
                    modalPrioritySelect.style.display = isPrompt ? 'block' : 'none';
                    modalPriorityLabel.style.display = isPrompt ? 'block' : 'none';
                    modalTimeSlotSelect.style.display = isPrompt || isReminderAssignment ? 'block' : 'none';
                    modalTimeSlotLabel.style.display = isPrompt || isReminderAssignment ? 'block' : 'none';
                    modalDurationSelect.style.display = isPrompt || isReminderAssignment ? 'block' : 'none';
                    modalDurationLabel.style.display = isPrompt || isReminderAssignment ? 'block' : 'none';
                    modalResponsibleInput.style.display = isPrompt ? 'block' : 'none'; // Show responsible input for task editing
                    modalResponsibleLabel.style.display = isPrompt ? 'block' : 'none'; // Show responsible label for task editing


                    // Adjust modal size
                    if (isLarge) {
                        customModal.querySelector('.modal-content').classList.add('large');
                    } else {
                        customModal.querySelector('.modal-content').classList.remove('large');
                    }


                    if (isPrompt || isReminderAssignment) {
                        modalInput.value = defaultValue;
                        modalInput.focus();
                        modalInput.select();
                        modalPrioritySelect.value = currentPriority;
                        modalResponsibleInput.value = currentResponsible; // Set current responsible

                        modalTimeSlotSelect.innerHTML = '<option value="">Unassigned</option>'; // Option for unassigned
                        const all15MinTimeSlots = generateAll15MinTimeSlots();

                        const tasksForCurrentDate = timeboxData.tasksByDate[formatDate(currentDate)] || [];

                        all15MinTimeSlots.forEach(slot => {
                            const hypotheticalTask = {
                                id: generateUniqueId(), // A fresh dummy ID for each hypothetical slot
                                text: defaultValue,
                                priority: currentPriority,
                                assignedSlot: slot.time,
                                duration: currentDuration
                            };

                            // Pass the ID of the item being edited so checkOverlap can exclude it
                            if (!checkOverlap(hypotheticalTask, tasksForCurrentDate, timeboxData.fixedActivities, itemIdBeingEdited)) {
                                const option = document.createElement('option');
                                option.value = slot.time;
                                option.textContent = slot.time;
                                modalTimeSlotSelect.appendChild(option);
                            }
                        });
                        modalTimeSlotSelect.value = currentAssignedSlot || '';

                        modalDurationSelect.innerHTML = '';
                        durationOptions.forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt.value;
                            option.textContent = opt.text;
                            modalDurationSelect.appendChild(option);
                        });
                        modalDurationSelect.value = currentDuration;
                    }

                    modalCancelBtn.style.display = isConfirm || isPrompt || isReminderAssignment ? 'inline-block' : 'none';
                    modalConfirmBtn.textContent = isPrompt || isReminderAssignment ? 'Save' : (isConfirm ? 'Yes' : 'OK');

                    customModal.classList.add('active');

                    const handleConfirm = () => {
                        customModal.classList.remove('active');
                        modalConfirmBtn.removeEventListener('click', handleConfirm);
                        modalCancelBtn.removeEventListener('click', handleCancel);
                        if (isPrompt || isReminderAssignment) {
                            resolve({
                                text: modalInput.value.trim(),
                                priority: modalPrioritySelect.value,
                                assignedSlot: modalTimeSlotSelect.value || null,
                                duration: parseInt(modalDurationSelect.value),
                                responsible: modalResponsibleInput.value.trim() // Get responsible value
                            });
                        } else {
                            resolve(true);
                        }
                    };

                    const handleCancel = () => {
                        customModal.classList.remove('active');
                        modalConfirmBtn.removeEventListener('click', handleConfirm);
                        modalCancelBtn.removeEventListener('click', handleCancel);
                        resolve(false);
                    };

                    modalConfirmBtn.addEventListener('click', handleConfirm);
                    modalCancelBtn.addEventListener('click', handleCancel);

                    const handleKeyPress = (e) => {
                        if (e.key === 'Enter' && (isPrompt || isReminderAssignment)) {
                            handleConfirm();
                            document.removeEventListener('keypress', handleKeyPress);
                        }
                    };
                    if (isPrompt || isReminderAssignment) {
                        document.addEventListener('keypress', handleKeyPress);
                    }
                });
            };

            // Function to generate all 15-minute time slots (internal use for grid structure and logic)
            const generateAll15MinTimeSlots = () => {
                const slots = [];
                for (let h = 8; h <= 22; h++) {
                    for (let m = 0; m < 60; m += 15) {
                        const hour = String(h).padStart(2, '0');
                        const minute = String(m).padStart(2, '0');
                        slots.push({ time: `${hour}:${minute}` });
                    }
                }
                return slots;
            };

            // --- Page Navigation Logic ---
            let currentPageId = 'capture-page'; // Default active page

            const showPage = (pageId) => {
                appPages.forEach(page => page.classList.remove('active'));
                document.getElementById(pageId).classList.add('active');

                navButtons.forEach(button => button.classList.remove('active'));
                document.querySelector(`button[data-page="${pageId}"]`).classList.add('active');

                currentPageId = pageId;

                // Re-render content for the active page
                switch (pageId) {
                    case 'capture-page':
                        renderCapturePage();
                        break;
                    case 'fixed-activities-page':
                        renderFixedActivitiesPage();
                        break;
                    case 'statistics-page':
                        renderStatisticsPage();
                        break;
                    case 'dashboard-page':
                        renderDashboardPage();
                        break;
                }
            };

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showPage(button.dataset.page);
                });
            });

            // --- Render Functions for Each Page ---

            const renderCapturePage = () => {
                captureDateInput.value = formatDate(currentDate);
                renderUnassignedTasks();
                renderReminders();
                renderSchedule();
            };

            const renderFixedActivitiesPage = () => {
                fixedTaskList.innerHTML = '';
                if (timeboxData.fixedActivities.length === 0) {
                    emptyFixedState.style.display = 'block';
                } else {
                    emptyFixedState.style.display = 'none';
                    const priorityOrder = { 'Urgent': 1, 'Important': 2, 'Normal': 3 };
                    timeboxData.fixedActivities.sort((a, b) => {
                        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                        if (priorityDiff !== 0) return priorityDiff;
                        if (a.defaultAssignedSlot && b.defaultAssignedSlot) {
                            return timeToMinutes(a.defaultAssignedSlot) - timeToMinutes(b.defaultAssignedSlot);
                        }
                        if (b.defaultAssignedSlot) return 1;
                        if (a.defaultAssignedSlot) return -1;
                        return 0;
                    });

                    timeboxData.fixedActivities.forEach(fixedTask => {
                        const listItem = createTaskListItem(fixedTask, false, 'fixed');
                        fixedTaskList.appendChild(listItem);
                    });
                }
                // Removed population of fixedDurationSelect and fixedTimeSlotSelect as they are no longer in the initial input section
            };

            const renderStatisticsPage = () => {
                statsDateInput.value = formatDate(statsDate);
                const dailyStats = timeboxData.dailyScores[formatDate(statsDate)] || { goalScore: 0, completedTasksCount: 0, totalScore: 0 };
                const dailyObservations = timeboxData.dailyObservations[formatDate(statsDate)] || '';

                let calculatedGoalScore = 0;
                // Calculate goal score from regular tasks
                const tasksForToday = timeboxData.tasksByDate[formatDate(statsDate)] || [];
                tasksForToday.filter(task => task.assignedSlot !== null).forEach(task => {
                    calculatedGoalScore += Math.min(13, (priorityScores[task.priority] || 0) * (durationScores[task.duration] || 0));
                });
                // Calculate goal score from fixed activities
                timeboxData.fixedActivities.forEach(fixedTask => {
                    if (fixedTask.defaultAssignedSlot) {
                        calculatedGoalScore += Math.min(13, (priorityScores[fixedTask.priority] || 0) * (durationScores[fixedTask.duration] || 0));
                    }
                });

                // Update the stored goalScore for the day
                dailyStats.goalScore = calculatedGoalScore;
                timeboxData.dailyScores[formatDate(statsDate)] = dailyStats; // Ensure it's saved back
                saveAllData(); // Save the updated dailyScores

                goalScoreSpan.textContent = dailyStats.goalScore;
                completedTasksCountSpan.textContent = dailyStats.completedTasksCount;
                totalScoreSpan.textContent = dailyStats.totalScore;

                const percentage = dailyStats.goalScore > 0 ? ((dailyStats.totalScore / dailyStats.goalScore) * 100).toFixed(2) : 0;
                completionPercentageSpan.textContent = `${percentage}%`;

                observationsTextarea.value = dailyObservations;

                if (dailyStats.completedTasksCount === 0 && dailyStats.goalScore === 0) {
                    emptyStatsState.style.display = 'block';
                } else {
                    emptyStatsState.style.display = 'none';
                }
            };

            const renderDashboardPage = () => {
                // Get data for the last 7 days, but only for dates with actual scores
                const labels = [];
                const goalScores = [];
                const totalScores = [];
                let hasData = false;

                const allDatesWithScores = Object.keys(timeboxData.dailyScores).sort();

                // Filter dates to only include those with data within the last 7 days
                const recentDatesWithData = allDatesWithScores.filter(dateString => {
                    const date = new Date(dateString);
                    const diffTime = Math.abs(currentDate.getTime() - date.getTime());
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    return diffDays <= 7 && (timeboxData.dailyScores[dateString].goalScore > 0 || timeboxData.dailyScores[dateString].totalScore > 0);
                });

                // Populate labels and scores only for dates with data
                recentDatesWithData.forEach(dateString => {
                    labels.push(dateString);
                    const dailyStats = timeboxData.dailyScores[dateString];
                    goalScores.push(dailyStats.goalScore);
                    totalScores.push(dailyStats.totalScore);
                    hasData = true; // Mark that we have data
                });

                if (!hasData) {
                    emptyDashboardState.style.display = 'block';
                    dashboardCanvas.style.display = 'none';
                    if (scoreChartInstance) {
                        scoreChartInstance.destroy();
                        scoreChartInstance = null;
                    }
                    return;
                } else {
                    emptyDashboardState.style.display = 'none';
                    dashboardCanvas.style.display = 'block';
                }

                const chartData = {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Puntaje Objetivo',
                            data: goalScores,
                            backgroundColor: 'rgba(0, 188, 212, 0.7)', // Primary color with transparency
                            borderColor: 'rgba(0, 188, 212, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Puntaje Total Alcanzado',
                            data: totalScores,
                            backgroundColor: 'rgba(255, 235, 59, 0.7)', // Secondary color with transparency
                            borderColor: 'rgba(255, 235, 59, 1)',
                            borderWidth: 1
                        }
                    ]
                };

                const chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Puntaje' // Spanish title
                            },
                            ticks: {
                                precision: 0 // Ensure integer ticks for scores
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Fecha' // Spanish title
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Comparación de Puntajes Diarios (Últimos 7 Días con Datos)', // Spanish title
                            color: 'black', // Title color
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            padding: {
                                top: 10,
                                bottom: 10
                            },
                            backgroundColor: 'white', // White background for title
                            borderRadius: 5
                        },
                        legend: {
                            labels: {
                                boxWidth: 20,
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    }
                };

                if (scoreChartInstance) {
                    scoreChartInstance.data = chartData;
                    scoreChartInstance.options = chartOptions;
                    scoreChartInstance.update();
                } else {
                    scoreChartInstance = new Chart(dashboardCanvas, {
                        type: 'bar',
                        data: chartData,
                        options: chartOptions
                    });
                }
            };


            const renderUnassignedTasks = () => {
                unassignedTaskList.innerHTML = '';
                const tasksForCurrentDate = timeboxData.tasksByDate[formatDate(currentDate)] || [];
                const unassigned = tasksForCurrentDate.filter(task => task.assignedSlot === null && !task.isFixed);

                if (unassigned.length === 0) {
                    emptyUnassignedState.style.display = 'block';
                } else {
                    emptyUnassignedState.style.display = 'none';
                    const priorityOrder = { 'Urgent': 1, 'Important': 2, 'Normal': 3 };
                    unassigned.sort((a, b) => {
                        // Unassigned tasks don't have a completion checkbox, so no sorting by completed status here
                        return priorityOrder[a.priority] - priorityOrder[b.priority];
                    });

                    unassigned.forEach(task => {
                        // Pass isScheduleItem as false for unassigned tasks to hide checkbox
                        const listItem = createTaskListItem(task, false, 'task');
                        unassignedTaskList.appendChild(listItem);
                    });
                }
            };

            const renderReminders = () => {
                reminderList.innerHTML = '';
                const remindersForCurrentDate = timeboxData.remindersByDate[formatDate(currentDate)] || [];

                if (remindersForCurrentDate.length === 0) {
                    emptyReminderState.style.display = 'block';
                } else {
                    emptyReminderState.style.display = 'none';
                    const priorityOrder = { 'Urgent': 1, 'Important': 2, 'Normal': 3 };
                    remindersForCurrentDate.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);

                    remindersForCurrentDate.forEach(reminder => {
                        const listItem = createTaskListItem(reminder, false, 'reminder');
                        reminderList.appendChild(listItem);
                    });
                }
            };

            const renderSchedule = () => {
                scheduleGrid.innerHTML = '';
                const all15MinSlots = generateAll15MinTimeSlots();
                const timeToIndex = {};
                all15MinSlots.forEach((slot, index) => {
                    timeToIndex[slot.time] = index + 1;
                });

                let hasAssignedTasks = false;
                const occupiedCells = {};

                const tasksForSchedule = [];

                // Add regular tasks for the current date
                const regularTasksToday = timeboxData.tasksByDate[formatDate(currentDate)] || [];
                regularTasksToday.forEach(task => {
                    if (task.assignedSlot) {
                        tasksForSchedule.push(task);
                    }
                });

                // Add fixed activities that have a default assigned slot
                timeboxData.fixedActivities.forEach(fixedTask => {
                    if (fixedTask.defaultAssignedSlot) {
                        // Check if this fixed task was completed on the current date
                        const isCompletedToday = fixedTask.completedDates && fixedTask.completedDates.includes(formatDate(currentDate));
                        tasksForSchedule.push({
                            id: fixedTask.id, // Use original ID for fixed tasks
                            text: fixedTask.text,
                            completed: isCompletedToday, // Set completion based on today's status
                            priority: fixedTask.priority,
                            assignedSlot: fixedTask.defaultAssignedSlot,
                            duration: fixedTask.duration,
                            isFixed: true,
                            responsible: fixedTask.responsible || ''
                        });
                    }
                });

                tasksForSchedule.sort((a, b) => {
                    const timeA = a.assignedSlot ? timeToMinutes(a.assignedSlot) : Infinity;
                    const timeB = b.assignedSlot ? timeToMinutes(b.assignedSlot) : Infinity;
                    return timeA - timeB;
                });


                tasksForSchedule.filter(task => task.assignedSlot !== null).forEach(task => {
                    const startMinutes = timeToMinutes(task.assignedSlot);
                    for (let i = 0; i < task.duration; i += 15) {
                        const currentMinutes = startMinutes + i;
                        const currentTime = minutesToTime(currentMinutes);
                        occupiedCells[currentTime] = task.id;
                    }
                });

                all15MinSlots.forEach((slot, index) => {
                    const timeLabelCell = document.createElement('div');
                    timeLabelCell.style.gridRowStart = index + 1;
                    timeLabelCell.style.gridColumn = 1;
                    timeLabelCell.classList.add('time-label-cell');

                    if (slot.time.endsWith(':00')) {
                        timeLabelCell.classList.add('hourly-label');
                        timeLabelCell.textContent = slot.time;
                    }
                    scheduleGrid.appendChild(timeLabelCell);

                    const assignedTask = tasksForSchedule.find(task => task.assignedSlot === slot.time);
                    const isContinuation = occupiedCells[slot.time] && !assignedTask;

                    if (assignedTask) {
                        hasAssignedTasks = true;
                        const taskItem = createTaskListItem(assignedTask, true, assignedTask.isFixed ? 'fixed-schedule' : 'task');
                        const rowSpan = assignedTask.duration / 15;
                        taskItem.style.gridRowStart = index + 1;
                        taskItem.style.gridRowEnd = `span ${rowSpan}`;
                        scheduleGrid.appendChild(taskItem);
                    } else if (!isContinuation) {
                        const emptyCell = document.createElement('div');
                        emptyCell.classList.add('schedule-cell');
                        emptyCell.style.gridRowStart = index + 1;
                        emptyCell.style.gridColumn = 2;
                        scheduleGrid.appendChild(emptyCell);
                    }
                });

                const currentDayTasks = timeboxData.tasksByDate[formatDate(currentDate)] || [];
                if (!hasAssignedTasks && (currentDayTasks.filter(t => t.assignedSlot !== null).length === 0) && (timeboxData.fixedActivities.filter(f => f.defaultAssignedSlot !== null).length === 0)) {
                    emptyScheduleState.style.display = 'block';
                } else {
                    emptyScheduleState.style.display = 'none';
                }
            };

            const createTaskListItem = (item, isScheduleItem, type) => {
                const itemElement = document.createElement(isScheduleItem ? 'div' : 'li');
                itemElement.classList.add(isScheduleItem ? 'schedule-task-item' : 'task-item');
                itemElement.dataset.itemId = item.id;
                itemElement.dataset.itemType = type;
                itemElement.classList.add(`priority-${item.priority}`);
                if (item.completed) {
                    itemElement.classList.add('completed');
                }
                if (item.isFixed) {
                    itemElement.classList.add('is-fixed');
                }

                let actionsHtml = '';
                let checkboxHtml = '';
                let scoreHtml = '';
                let responsibleHtml = item.responsible ? `<span class="task-responsible-display">Responsible: ${item.responsible}</span>` : '';

                if (type === 'task') {
                    // Only show checkbox if it's a schedule item
                    if (isScheduleItem) {
                        checkboxHtml = `<input type="checkbox" class="task-checkbox" ${item.completed ? 'checked' : ''} aria-label="Complete activity">`;
                    }
                    actionsHtml = `
                        <button class="edit-btn" aria-label="Edit activity">&#9998;</button>
                        <button class="delete-btn" aria-label="Delete activity">&times;</button>
                    `;
                    if (isScheduleItem) {
                        const score = Math.min(13, (priorityScores[item.priority] || 0) * (durationScores[item.duration] || 0));
                        scoreHtml = `<span class="task-score">Score: ${score}</span>`;
                    }
                } else if (type === 'reminder') {
                    actionsHtml = `
                        <button class="assign-btn" aria-label="Assign reminder">Assign</button>
                        <button class="edit-reminder-btn" aria-label="Edit reminder">&#9998;</button>
                        <button class="delete-reminder-btn" aria-label="Delete reminder">&times;</button>
                    `;
                } else if (type === 'fixed') {
                    actionsHtml = `
                        <button class="edit-fixed-btn" aria-label="Edit fixed activity">&#9998;</button>
                        <button class="delete-fixed-btn" aria-label="Delete fixed activity">&times;</button>
                    `;
                } else if (type === 'fixed-schedule') {
                    // Checkbox for fixed activities in schedule is now enabled
                    checkboxHtml = `<input type="checkbox" class="task-checkbox" ${item.completed ? 'checked' : ''} aria-label="Complete activity">`;
                    actionsHtml = `
                        <span style="font-size: 0.8em; color: var(--text-color);">Fixed</span>
                    `;
                    if (isScheduleItem) {
                        const score = Math.min(13, (priorityScores[item.priority] || 0) * (durationScores[item.duration] || 0));
                        scoreHtml = `<span class="task-score">Score: ${score}</span>`;
                    }
                }

                itemElement.innerHTML = `
                    ${checkboxHtml}
                    <div class="task-content">
                        <span class="task-text">${item.text}</span>
                        <span class="task-priority-display">Priority: ${item.priority} - ${item.duration} min</span>
                        ${responsibleHtml}
                    </div>
                    <div class="task-actions">
                        ${actionsHtml}
                    </div>
                    ${scoreHtml}
                `;
                return itemElement;
            };

            const saveAllData = () => {
                localStorage.setItem('timebox_data', JSON.stringify(timeboxData));
            };

            const checkOverlap = (newTask, currentDayTasks, fixedActivities, excludeId = null) => {
                if (!newTask.assignedSlot) return false;

                const newStartMinutes = timeToMinutes(newTask.assignedSlot);
                const newEndMinutes = newStartMinutes + newTask.duration;

                const tasksToExamine = [];

                // Add current day's tasks
                currentDayTasks.forEach(task => {
                    if (task.id !== excludeId) { // Exclude the task being edited
                        tasksToExamine.push(task);
                    }
                });

                // Add fixed activities
                fixedActivities.forEach(fixedTask => {
                    if (fixedTask.defaultAssignedSlot) {
                        // For overlap check, treat fixed tasks as if they are always present
                        // Use a unique ID for the fixed task in this context for exclusion
                        const fixedTaskCheckId = `fixed-overlap-check-${fixedTask.id}`;
                        if (fixedTaskCheckId !== excludeId) {
                            tasksToExamine.push({
                                id: fixedTaskCheckId,
                                assignedSlot: fixedTask.defaultAssignedSlot,
                                duration: fixedTask.duration
                            });
                        }
                    }
                });

                for (const existingTask of tasksToExamine) {
                    if (!existingTask.assignedSlot) continue;

                    const existingStartMinutes = timeToMinutes(existingTask.assignedSlot);
                    const existingEndMinutes = existingStartMinutes + existingTask.duration;

                    if (newStartMinutes < existingEndMinutes && newEndMinutes > existingStartMinutes) {
                        return true;
                    }
                }
                return false;
            };

            // AI Analysis Function
            const getAIAnalysis = (dailyStats, observations) => {
                const totalScore = dailyStats.totalScore;
                const goalScore = dailyStats.goalScore;
                const completedTasks = dailyStats.completedTasksCount;
                const percentage = dailyStats.goalScore > 0 ? (totalScore / goalScore) * 100 : 0;

                let analysisHtml = `<h3>Análisis de Rendimiento Diario</h3>`;
                analysisHtml += `<p>Tu puntaje total del día es <strong>${totalScore}</strong> de un objetivo de <strong>${goalScore}</strong>, logrando un <strong>${percentage.toFixed(2)}%</strong> de completado. Completaste <strong>${completedTasks}</strong> actividades.</p>`;

                if (observations) {
                    analysisHtml += `<p><strong>Tus observaciones:</strong> "${observations}"</p>`;
                }

                analysisHtml += `<h4>Perspectivas y Sugerencias (Inspiradas en el Timeboxing de Elon Musk)</h4>`;

                if (percentage >= 90) {
                    analysisHtml += `<p><strong>¡Rendimiento Excelente!</strong> Has demostrado una dedicación y ejecución excepcionales. Esto se alinea con el principio de Musk de dedicación extrema y largas horas. Revisa tus procesos para una mayor optimización, quizás identificando tareas aún más críticas para el día siguiente.</p>`;
                } else if (percentage >= 70) {
                    analysisHtml += `<p><strong>¡Gran Progreso!</strong> Estás gestionando tu tiempo de manera efectiva. Para alcanzar el siguiente nivel, considera si tus bloques de tiempo están realmente optimizados. ¿Estás minimizando el cambio de contexto? Musk es conocido por sus rápidas transiciones de tareas; intenta agrupar tareas similares para reducir la carga mental.</p>`;
                    if (observations.toLowerCase().includes('presionado') || observations.toLowerCase().includes('surgieron actividades')) {
                        analysisHtml += `<p>Tus observaciones sobre sentirte presionado o la aparición de actividades no planeadas sugieren que, como Musk, debes estar preparado para adaptarte. Él a menudo ajusta sus planes en el día. Considera dejar pequeños "bloques de amortiguación" en tu agenda para imprevistos o tareas urgentes que surjan.</p>`;
                    }
                } else if (percentage >= 50) {
                    analysisHtml += `<p><strong>¡Buen Esfuerzo!</strong> Hay margen de mejora. Reflexiona sobre tu planificación. ¿Fueron realistas tus estimaciones de tiempo? ¿Surgieron interrupciones imprevistas? Musk enfatiza la priorización implacable. Identifica las tareas de "ruta crítica" –aquellas que absolutamente deben hacerse– y asegúrate de que se les asignen los mejores bloques de tiempo.</p>`;
                    if (observations.toLowerCase().includes('presionado') || observations.toLowerCase().includes('surgieron actividades')) {
                        analysisHtml += `<p>Tus comentarios sobre sentirte presionado y las interrupciones son clave. Musk descompone objetivos complejos en tareas pequeñas y manejables. Intenta simplificar tus objetivos diarios y concéntrate en lograr algunos elementos de alto impacto. La flexibilidad es crucial cuando surgen desafíos inesperados.</p>`;
                    }
                } else {
                    analysisHtml += `<p><strong>Oportunidad de Crecimiento:</strong> Tu timeboxing actual podría necesitar ajustes significativos. ¿Tus tareas estaban claramente definidas? ¿Te distraíste? Musk descompone objetivos complejos en tareas pequeñas y manejables. Intenta simplificar tus objetivos diarios y concéntrate en lograr algunos elementos de alto impacto. No temas ajustar tu horario durante el día; la flexibilidad es clave cuando surgen desafíos inesperados.</p>`;
                    if (observations.toLowerCase().includes('presionado') || observations.toLowerCase().includes('surgieron actividades')) {
                        analysisHtml += `<p>La presión y las actividades no planeadas que mencionas son desafíos comunes. Musk sugiere incluso dividir las tareas en bloques de 5 minutos si es necesario para superar la inercia y mantener el impulso. Revisa tu lista de tareas y asegúrate de que cada bloque sea lo más enfocado posible.</p>`;
                    }
                }

                if (completedTasks === 0 && goalScore > 0) {
                    analysisHtml += `<p>Parece que hoy no se completaron tareas. Reevalúa tu desglose de tareas. ¿Son tus tareas demasiado grandes? Musk sugiere dividir las tareas en bloques de 5 minutos si es necesario para superar la inercia.</p>`;
                } else if (completedTasks > 0 && percentage < 50) {
                    analysisHtml += `<p>Completaste algunas tareas, pero el puntaje general es bajo. Esto podría indicar que las tareas de alta prioridad o de larga duración quedaron incompletas. Concéntrate en abordar primero las tareas más impactantes, incluso si son desafiantes.</p>`;
                }

                analysisHtml += `<p>Recuerda, el timeboxing se trata de intencionalidad. Cada minuto cuenta. Reevalúa, adapta e itera tu enfoque diariamente.</p>`;
                return analysisHtml;
            };


            // --- Event Listeners ---

            // Date selection for Capture Page
            captureDateInput.addEventListener('change', (e) => {
                currentDate = new Date(e.target.value);
                renderCapturePage();
                renderDashboardPage(); // Update dashboard when date changes
            });

            // Date selection for Statistics Page
            statsDateInput.addEventListener('change', (e) => {
                statsDate = new Date(e.target.value);
                renderStatisticsPage();
            });

            // Add new task
            addTaskBtn.addEventListener('click', async () => {
                const taskText = taskInput.value.trim();
                // Default priority to Normal when adding a new task
                const taskPriority = 'Normal';
                if (taskText !== '') {
                    if (!timeboxData.tasksByDate[formatDate(currentDate)]) {
                        timeboxData.tasksByDate[formatDate(currentDate)] = [];
                    }
                    // Added responsible field to the task object
                    timeboxData.tasksByDate[formatDate(currentDate)].push({ id: generateUniqueId(), text: taskText, completed: false, priority: taskPriority, assignedSlot: null, duration: 30, isFixed: false, responsible: '' });
                    taskInput.value = '';
                    saveAllData();
                    renderCapturePage();
                } else {
                    await showModal('Atención', 'Por favor, introduce una actividad.');
                }
            });

            // Add new reminder
            addReminderBtn.addEventListener('click', async () => {
                const reminderText = reminderInput.value.trim();
                if (reminderText !== '') {
                    if (!timeboxData.remindersByDate[formatDate(currentDate)]) {
                        timeboxData.remindersByDate[formatDate(currentDate)] = [];
                    }
                    timeboxData.remindersByDate[formatDate(currentDate)].push({ id: generateUniqueId(), text: reminderText, priority: 'Normal', duration: 30 });
                    reminderInput.value = '';
                    saveAllData();
                    renderCapturePage();
                } else {
                    await showModal('Atención', 'Por favor, introduce un recordatorio.');
                }
            });

            // Add new fixed activity
            addFixedTaskBtn.addEventListener('click', async () => {
                const fixedText = fixedTaskInput.value.trim();
                // Default values for new fixed tasks
                const fixedPriority = 'Normal';
                const fixedDuration = 30;
                const fixedTimeSlot = null;

                if (fixedText !== '') {
                    const newFixedTask = {
                        id: generateUniqueId(),
                        text: fixedText,
                        priority: fixedPriority,
                        duration: fixedDuration,
                        defaultAssignedSlot: fixedTimeSlot,
                        responsible: '', // Default empty responsible for fixed tasks
                        completedDates: [] // Initialize completedDates array for fixed tasks
                    };

                    // No overlap check needed here as no time slot is assigned initially
                    timeboxData.fixedActivities.push(newFixedTask);
                    fixedTaskInput.value = '';
                    saveAllData();
                    renderFixedActivitiesPage();
                    if (currentPageId === 'capture-page') renderSchedule();
                } else {
                    await showModal('Atención', 'Por favor, introduce una actividad fija.');
                }
            });

            // Save Observations
            saveObservationsBtn.addEventListener('click', async () => {
                const observations = observationsTextarea.value.trim();
                const confirmed = await showModal('Confirmar Guardado', '¿Estás seguro de que quieres guardar estas observaciones?', false, '', true);
                if (confirmed) {
                    timeboxData.dailyObservations[formatDate(statsDate)] = observations;
                    saveAllData();

                    // Get daily stats for AI analysis
                    const dailyStats = timeboxData.dailyScores[formatDate(statsDate)] || { goalScore: 0, completedTasksCount: 0, totalScore: 0 };
                    const aiAnalysis = getAIAnalysis(dailyStats, observations);

                    // Use innerHTML to render the HTML content from AI analysis
                    await showModal('Análisis y Sugerencias de IA', aiAnalysis, false, '', false, 'Normal', null, 30, false, true); // isLarge = true
                    modalMessage.innerHTML = aiAnalysis; // Set innerHTML after modal is shown
                }
            });


            // Allow adding task/reminder/fixed with Enter key
            taskInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTaskBtn.click(); });
            reminderInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addReminderBtn.click(); });
            fixedTaskInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addFixedTaskBtn.click(); });


            // Handle click events on all lists (event delegation)
            document.addEventListener('click', async (e) => {
                const itemElement = e.target.closest('.task-item, .schedule-task-item');
                if (!itemElement) return;

                const itemId = itemElement.dataset.itemId;
                const itemType = itemElement.dataset.itemType;
                const formattedCurrentDate = formatDate(currentDate);

                // Handle task checkbox (for regular tasks and fixed-schedule items)
                if (e.target.classList.contains('task-checkbox') && (itemType === 'task' || itemType === 'fixed-schedule')) {
                    const isChecked = e.target.checked;
                    let taskToUpdate = null;
                    let originalScore = 0;

                    if (itemType === 'task') {
                        const tasksForCurrentDate = timeboxData.tasksByDate[formattedCurrentDate] || [];
                        const taskIndex = tasksForCurrentDate.findIndex(t => t.id === itemId);
                        if (taskIndex !== -1) {
                            taskToUpdate = tasksForCurrentDate[taskIndex];
                            originalScore = Math.min(13, (priorityScores[taskToUpdate.priority] || 0) * (durationScores[taskToUpdate.duration] || 0));
                            taskToUpdate.completed = isChecked;
                        }
                    } else if (itemType === 'fixed-schedule') {
                        const fixedTask = timeboxData.fixedActivities.find(f => f.id === itemId);
                        if (fixedTask) {
                            taskToUpdate = fixedTask;
                            originalScore = Math.min(13, (priorityScores[taskToUpdate.priority] || 0) * (durationScores[taskToUpdate.duration] || 0));
                            if (!taskToUpdate.completedDates) {
                                taskToUpdate.completedDates = [];
                            }
                            if (isChecked) {
                                if (!taskToUpdate.completedDates.includes(formattedCurrentDate)) {
                                    taskToUpdate.completedDates.push(formattedCurrentDate);
                                }
                            } else {
                                const dateIndex = taskToUpdate.completedDates.indexOf(formattedCurrentDate);
                                if (dateIndex > -1) {
                                    taskToUpdate.completedDates.splice(dateIndex, 1);
                                }
                            }
                        }
                    }

                    if (taskToUpdate) {
                        if (!timeboxData.dailyScores[formattedCurrentDate]) {
                            timeboxData.dailyScores[formattedCurrentDate] = { goalScore: 0, completedTasksCount: 0, totalScore: 0 };
                        }

                        if (isChecked) {
                            timeboxData.dailyScores[formattedCurrentDate].completedTasksCount++;
                            timeboxData.dailyScores[formattedCurrentDate].totalScore += originalScore;
                        } else {
                            timeboxData.dailyScores[formattedCurrentDate].completedTasksCount--;
                            timeboxData.dailyScores[formattedCurrentDate].totalScore -= originalScore;
                        }
                        saveAllData();
                        renderCapturePage(); // Re-render to reflect changes
                    }
                }

                // Handle task edit (for tasks)
                if (e.target.classList.contains('edit-btn') && itemType === 'task') {
                    const tasksForCurrentDate = timeboxData.tasksByDate[formattedCurrentDate] || [];
                    const taskIndex = tasksForCurrentDate.findIndex(t => t.id === itemId);
                    if (taskIndex === -1) return;
                    const task = tasksForCurrentDate[taskIndex];

                    const result = await showModal(
                        'Editar Actividad',
                        'Edita el texto, prioridad, franja horaria, duración y responsable de tu actividad:',
                        true,
                        task.text,
                        true,
                        task.priority,
                        task.assignedSlot,
                        task.duration,
                        false, // isReminderAssignment
                        task.id, // Pass the ID of the task being edited
                        task.responsible || '' // Pass current responsible
                    );

                    if (result && result.text !== null && result.text.trim() !== '') {
                        // If the task was assigned, remove its score contribution from goalScore before updating
                        const oldAssignedSlot = task.assignedSlot;
                        const oldScoreContribution = Math.min(13, (priorityScores[task.priority] || 0) * (durationScores[task.duration] || 0));

                        const updatedTask = {
                            ...task,
                            text: result.text.trim(),
                            priority: result.priority,
                            assignedSlot: result.assignedSlot,
                            duration: result.duration,
                            responsible: result.responsible // Update responsible
                        };

                        if (updatedTask.assignedSlot && checkOverlap(updatedTask, tasksForCurrentDate, timeboxData.fixedActivities, updatedTask.id)) {
                            await showModal('Error de Asignación', `La actividad se superpone con otra tarea en el horario. Por favor, elige otra franja horaria o duración.`);
                            return;
                        }

                        tasksForCurrentDate[taskIndex] = updatedTask;

                        // Update dailyScores based on new assignment or changes
                        if (!timeboxData.dailyScores[formattedCurrentDate]) {
                            timeboxData.dailyScores[formattedCurrentDate] = { goalScore: 0, completedTasksCount: 0, totalScore: 0 };
                        }
                        const newScoreContribution = Math.min(13, (priorityScores[updatedTask.priority] || 0) * (durationScores[updatedTask.duration] || 0));

                        if (oldAssignedSlot && !updatedTask.assignedSlot) { // Was assigned, now unassigned
                            timeboxData.dailyScores[formattedCurrentDate].goalScore -= oldScoreContribution;
                            if (updatedTask.completed) { // If it was completed, also revert total score
                                timeboxData.dailyScores[formattedCurrentDate].completedTasksCount--;
                                timeboxData.dailyScores[formattedCurrentDate].totalScore -= oldScoreContribution;
                            }
                        } else if (!oldAssignedSlot && updatedTask.assignedSlot) { // Was unassigned, now assigned
                            timeboxData.dailyScores[formattedCurrentDate].goalScore += newScoreContribution;
                        } else if (oldAssignedSlot && updatedTask.assignedSlot) { // Assigned, still assigned (might have changed slot/duration/priority)
                            timeboxData.dailyScores[formattedCurrentDate].goalScore = timeboxData.dailyScores[formattedCurrentDate].goalScore - oldScoreContribution + newScoreContribution;
                            if (updatedTask.completed) { // If it's still completed, update total score with new score
                                timeboxData.dailyScores[formattedCurrentDate].totalScore = timeboxData.dailyScores[formattedCurrentDate].totalScore - oldScoreContribution + newScoreContribution;
                            }
                        }
                        // If task was completed, and its score changes, update totalScore as well
                        if (updatedTask.completed && oldScoreContribution !== newScoreContribution) {
                            timeboxData.dailyScores[formattedCurrentDate].totalScore = timeboxData.dailyScores[formattedCurrentDate].totalScore - oldScoreContribution + newScoreContribution;
                        }


                        saveAllData();
                        renderCapturePage();
                    }
                }

                // Handle task delete (for tasks)
                if (e.target.classList.contains('delete-btn') && itemType === 'task') {
                    const tasksForCurrentDate = timeboxData.tasksByDate[formattedCurrentDate] || [];
                    const taskIndex = tasksForCurrentDate.findIndex(t => t.id === itemId);
                    if (taskIndex === -1) return;

                    const confirmed = await showModal('Confirmar Eliminación', '¿Estás seguro de que quieres eliminar esta actividad?', false, '', true);
                    if (confirmed) {
                        const taskToDelete = tasksForCurrentDate[taskIndex];
                        const score = Math.min(13, (priorityScores[taskToDelete.priority] || 0) * (durationScores[taskToDelete.duration] || 0));

                        if (!timeboxData.dailyScores[formattedCurrentDate]) {
                            timeboxData.dailyScores[formattedCurrentDate] = { goalScore: 0, completedTasksCount: 0, totalScore: 0 };
                        }

                        // If task was assigned, remove its score contribution from goalScore
                        if (taskToDelete.assignedSlot) {
                            timeboxData.dailyScores[formattedCurrentDate].goalScore -= score;
                        }
                        // If task was completed, revert score
                        if (taskToDelete.completed) {
                            timeboxData.dailyScores[formattedCurrentDate].completedTasksCount--;
                            timeboxData.dailyScores[formattedCurrentDate].totalScore -= score;
                        }
                        tasksForCurrentDate.splice(taskIndex, 1);
                        saveAllData();
                        renderCapturePage();
                    }
                }

                // Handle reminder assign (for reminders)
                if (e.target.classList.contains('assign-btn') && itemType === 'reminder') {
                    const remindersForCurrentDate = timeboxData.remindersByDate[formattedCurrentDate] || [];
                    const reminderIndex = remindersForCurrentDate.findIndex(r => r.id === itemId);
                    if (reminderIndex === -1) return;
                    const reminder = remindersForCurrentDate[reminderIndex];

                    const result = await showModal(
                        'Asignar Recordatorio',
                        'Asigna este recordatorio a tu horario:',
                        false,
                        reminder.text,
                        true,
                        reminder.priority,
                        null,
                        reminder.duration,
                        true, // isReminderAssignment
                        null, // No item ID to exclude for new assignment
                        '' // No responsible for reminders
                    );

                    if (result && result.text !== null && result.text.trim() !== '') {
                        const tasksForCurrentDate = timeboxData.tasksByDate[formattedCurrentDate] || [];
                        const newTask = {
                            id: generateUniqueId(),
                            text: result.text.trim(),
                            completed: false,
                            priority: result.priority,
                            assignedSlot: result.assignedSlot,
                            duration: result.duration,
                            isFixed: false,
                            responsible: '' // Reminders don't have responsible field when assigned
                        };

                        if (newTask.assignedSlot && checkOverlap(newTask, tasksForCurrentDate, timeboxData.fixedActivities, null)) {
                            await showModal('Error de Asignación', `La actividad se superpone con otra tarea en el horario. Por favor, elige otra franja horaria o duración.`);
                            return;
                        }

                        tasksForCurrentDate.push(newTask);
                        remindersForCurrentDate.splice(reminderIndex, 1);

                        // Update goalScore for newly assigned task
                        if (newTask.assignedSlot) {
                            if (!timeboxData.dailyScores[formattedCurrentDate]) {
                                timeboxData.dailyScores[formattedCurrentDate] = { goalScore: 0, completedTasksCount: 0, totalScore: 0 };
                            }
                            const score = Math.min(13, (priorityScores[newTask.priority] || 0) * (durationScores[newTask.duration] || 0));
                            timeboxData.dailyScores[formattedCurrentDate].goalScore += score;
                        }

                        saveAllData();
                        renderCapturePage();
                    }
                }

                // Handle reminder edit (for reminders)
                if (e.target.classList.contains('edit-reminder-btn') && itemType === 'reminder') {
                    const remindersForCurrentDate = timeboxData.remindersByDate[formattedCurrentDate] || [];
                    const reminderIndex = remindersForCurrentDate.findIndex(r => r.id === itemId);
                    if (reminderIndex === -1) return;
                    const reminder = remindersForCurrentDate[reminderIndex];

                    const result = await showModal(
                        'Editar Recordatorio',
                        'Edita el texto, prioridad y duración de tu recordatorio:',
                        true,
                        reminder.text,
                        true,
                        reminder.priority,
                        null,
                        reminder.duration,
                        false, // isReminderAssignment
                        null, // No item ID to exclude for reminders as they are not assigned to schedule
                        '' // No responsible for reminders
                    );

                    if (result && result.text !== null && result.text.trim() !== '') {
                        remindersForCurrentDate[reminderIndex].text = result.text.trim();
                        remindersForCurrentDate[reminderIndex].priority = result.priority;
                        remindersForCurrentDate[reminderIndex].duration = result.duration;
                        saveAllData();
                        renderCapturePage();
                    }
                }

                // Handle reminder delete (for reminders)
                if (e.target.classList.contains('delete-reminder-btn') && itemType === 'reminder') {
                    const remindersForCurrentDate = timeboxData.remindersByDate[formattedCurrentDate] || [];
                    const reminderIndex = remindersForCurrentDate.findIndex(r => r.id === itemId);
                    if (reminderIndex === -1) return;

                    const confirmed = await showModal('Confirmar Eliminación', '¿Estás seguro de que quieres eliminar este recordatorio?', false, '', true);
                    if (confirmed) {
                        remindersForCurrentDate.splice(reminderIndex, 1);
                        saveAllData();
                        renderCapturePage();
                    }
                }

                // Handle fixed activity edit (for fixed activities page)
                if (e.target.classList.contains('edit-fixed-btn') && itemType === 'fixed') {
                    const fixedIndex = timeboxData.fixedActivities.findIndex(f => f.id === itemId);
                    if (fixedIndex === -1) return;
                    const fixedTask = timeboxData.fixedActivities[fixedIndex];

                    const result = await showModal(
                        'Editar Actividad Fija',
                        'Edita el texto, prioridad, franja horaria, duración y responsable de tu actividad fija:',
                        true,
                        fixedTask.text,
                        true,
                        fixedTask.priority,
                        fixedTask.defaultAssignedSlot,
                        fixedTask.duration,
                        false, // isReminderAssignment
                        `fixed-overlap-check-${fixedTask.id}`, // Pass the ID of the fixed task being edited (with prefix)
                        fixedTask.responsible || '' // Pass current responsible
                    );

                    if (result && result.text !== null && result.text.trim() !== '') {
                        const updatedFixedTask = {
                            ...fixedTask,
                            text: result.text.trim(),
                            priority: result.priority,
                            defaultAssignedSlot: result.assignedSlot,
                            duration: result.duration,
                            responsible: result.responsible // Update responsible
                        };

                        // Check for overlap with current day's tasks if fixed task has a default slot
                        if (updatedFixedTask.defaultAssignedSlot && checkOverlap(updatedFixedTask, timeboxData.tasksByDate[formattedCurrentDate] || [], timeboxData.fixedActivities, `fixed-overlap-check-${updatedFixedTask.id}`)) {
                            await showModal('Error de Asignación', `Esta actividad fija se superpone con una tarea existente en el horario. Por favor, elige otra franja horaria o duración.`);
                            return;
                        }

                        timeboxData.fixedActivities[fixedIndex] = updatedFixedTask;
                        saveAllData();
                        renderFixedActivitiesPage();
                        if (currentPageId === 'capture-page') renderSchedule();
                    }
                }

                // Handle fixed activity delete (for fixed activities page)
                if (e.target.classList.contains('delete-fixed-btn') && itemType === 'fixed') {
                    const fixedIndex = timeboxData.fixedActivities.findIndex(f => f.id === itemId);
                    if (fixedIndex === -1) return;

                    const confirmed = await showModal('Confirmar Eliminación', '¿Estás seguro de que quieres eliminar esta actividad fija?', false, '', true);
                    if (confirmed) {
                        // When deleting a fixed activity, we need to adjust dailyScores for all days it might have been completed
                        const fixedTaskToDelete = timeboxData.fixedActivities[fixedIndex];
                        const score = Math.min(13, (priorityScores[fixedTaskToDelete.priority] || 0) * (durationScores[fixedTaskToDelete.duration] || 0));

                        if (fixedTaskToDelete.defaultAssignedSlot && fixedTaskToDelete.completedDates) {
                            fixedTaskToDelete.completedDates.forEach(date => {
                                if (timeboxData.dailyScores[date]) {
                                    timeboxData.dailyScores[date].goalScore -= score;
                                    timeboxData.dailyScores[date].completedTasksCount--;
                                    timeboxData.dailyScores[date].totalScore -= score;
                                }
                            });
                        }

                        timeboxData.fixedActivities.splice(fixedIndex, 1);
                        saveAllData();
                        renderFixedActivitiesPage();
                        if (currentPageId === 'capture-page') renderSchedule();
                    }
                }
            });

            // Initial render: set current date and show the default page
            captureDateInput.value = formatDate(currentDate);
            statsDateInput.value = formatDate(statsDate);
            showPage(currentPageId);
        });
    </script>
</body>
</html>
